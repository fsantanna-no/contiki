//   text	   data	    bss	    dec	    hex	filename
//  47510	    532	   5470	  53512	   d108	er-example-server.sky
//  46286	    256	   6302	  52844	   ce6c	er-example-server.sky


native constant _LEDS_GREEN;

native pure
    _coap_get_transaction_by_mid(),     // TODO
    _IS_OPTION(),
    _MIN(),
    _strlen(),
    _uip_ntohs();

native nohold
    _coap_clear_transaction(),
    _coap_init_message(),
    _coap_parse_message(),
    _coap_new_transaction(),    // TODO
    _coap_get_header_block2(),
    _coap_send_message(),   // TODO
    _coap_send_transaction(),   // TODO
    _coap_serialize_message(),
    _coap_set_header_block2(),
    _coap_set_header_token(),
    _coap_set_payload(),
    _PRINTF(), _PRINT6ADDR(), _PRINTBITS(),
    _service_cbk(),
    _uip_ipaddr_copy();


native do
    #include "dev/leds.h"
    #define COAP_RESPONSE_TIMEOUT_TICKS         (CLOCK_SECOND * COAP_RESPONSE_TIMEOUT)
    #define COAP_RESPONSE_TIMEOUT_BACKOFF_MASK  ((CLOCK_SECOND * COAP_RESPONSE_TIMEOUT * (COAP_RESPONSE_RANDOM_FACTOR - 1)) + 1.5)
end

input (int*,u16,_uip_ipaddr_t*,u16,_request_t,void*,_response_t,void*)
          COAP_REQUEST;

input _coap_packet_t* COAP_RESPONSE;

class Transaction with
    var u16            mid;
    var _uip_ipaddr_t* addr;
    var u16            port;

    var u16            packet_len;
    var u8 [_COAP_MAX_PACKET_SIZE+1]
                       packet;

    var _request_t     request_cb  = null;
    var void*          request_dt  = null;
    var _response_t    response_cb = null;
    var void*          response_dt = null;
do
    var _uip_ipaddr_t addr_;
        _uip_ipaddr_copy(&addr_, this.addr);

    var int err = _NO_ERROR;
    if this.request_cb != null then
        err = this.request_cb(&this, this.request_dt)
            finalize with
                nothing;    // nohold
            end;
    end

    if err == _NO_ERROR then

        var int con? = _COAP_TYPE_CON ==
          ((_COAP_HEADER_TYPE_MASK & this.packet[0]) >> _COAP_HEADER_TYPE_POSITION);

        var int interval =
            _COAP_RESPONSE_TIMEOUT_TICKS +
                (_random_rand() % (_clock_time_t) _COAP_RESPONSE_TIMEOUT_BACKOFF_MASK);
        _PRINTF("Initial interval %f\n", (_float)interval/_CLOCK_SECOND);

        var _coap_packet_t* response = null;

        loop i, _COAP_MAX_RETRANSMIT do

            _printf("Sending transaction %u %d %d\n", this.mid, this.port, this.packet_len);
            _coap_send_message(&addr_, this.port, this.packet, this.packet_len);
            if not con? then
                break;
            end

            par/or do
                await (interval)ms;
                interval = interval << 1; /* double */
                _PRINTF("Doubled (%u) interval %f\n", i,
                        (_float)interval/_CLOCK_SECOND);
            with
                var _coap_packet_t* msg;
                msg = await COAP_RESPONSE
                        until msg:mid == this.mid;
                response := msg;
                            // i'm not holding it below
                break;
            end
        end

        // TODO
        /* handle observers */
        //coap_remove_observer_by_client(&addr_, this.port);

        if con? and (this.response_cb != null) then
            this.response_cb(this.response_dt, response)
                finalize with
                    nothing;    // nohold
                end;
        end
    end
end

do // Transactions scope

    var int*            p_pret;
    var u16             p_mid;
    var _uip_ipaddr_t*  p_addr;
    var u16             p_port;
    var _request_t      p_cb1;
    var void*           p_dt1;
    var _response_t     p_cb2;
    var void*           p_dt2;

    every (p_pret,p_mid,p_addr,p_port,p_cb1,p_dt1,p_cb2,p_dt2) = COAP_REQUEST do
        *p_pret = spawn [1] Transaction with
            this.mid   = p_mid;
            this.addr  = p_addr;
            this.port  = p_port;
            this.request_cb  = p_cb1;
            this.request_dt  = p_dt1;
            this.response_cb = p_cb2;
            this.response_dt = p_dt2;
        end;
    end

end // Transactions scope
